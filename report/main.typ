#import "conf.typ" : conf
#show: conf.with(
  title: [Отчёт\ по практической подготовке],
  type: "pract",
  info: (
      author: (
        name: [Кудяков Артём Александрович],
        faculty: [компьютерных наук и информационных технологий],
        group: "351",
        sex: "male"
      ),
      inspector: (
        degree: "",
        name: ""
      )
  ),
  settings: (
    title_page: (
      enabled: true
    ),
    contents_page: (
      enabled: true
    )
  )
)

= Построение интерполяционного многочлена в общем виде

*Условие*

Необходимо найти интерполяционный многочлен в общем виде.

#table(rows: 2, columns: (1fr, 1fr, 1fr, 1fr, 1fr))[*$x$*][
  0][1][2][3][*$f(x)$*][1][2][9][28]

*Код*

```rust
use nalgebra::{DMatrix, DVector};

pub fn vandermonde_interpolation(x_nodes: &[f64],
                                 f_nodes: &[f64],
                                 x_targets: &[f64]) -> Vec<f64> {
    let n = x_nodes.len() - 1;
    let a_list = solve_matrix(n, x_nodes, f_nodes);
    x_targets
        .iter()
        .map(|x| {
            a_list
                .iter()
                .enumerate()
                .map(|(i, a_i)| x.powi(i as i32) * a_i)
                .sum()
        })
        .collect()
}

fn solve_matrix(n: usize, x_list: &[f64], f_list: &[f64]) -> Vec<f64> {
    let x_matrix: Vec<f64> = (0..=n)
        .into_iter()
        .map(|i| x_list.iter().map(move |x| x.powi(i as i32)))
        .flatten()
        .collect();

    let x_matrix = DMatrix::from_vec((n + 1) as usize, (n + 1) as usize, x_matrix);
    let f_vector = DVector::from_row_slice(f_list);

    x_matrix
        .lu()
        .solve(&f_vector)
        .expect("Failed to solve")
        .into_iter()
        .map(|a| *a)
        .collect()
}
```

*Результат*

```
Интерполяционный многолчен P_3
+---+---+-------+---+-------+---+--------+----+
| x | 0 | 0.5   | 1 | 1.5   | 2 | 2.5    | 3  |
+=============================================+
| f | 1 | 1.125 | 2 | 4.375 | 9 | 16.625 | 28 |
+---+---+-------+---+-------+---+--------+----+
```


= Интерполяционный многочлен в форме Лагранжа

*Условие*

По данным интерполяции из предыдущего задания построить интерполяционный многочлен
в форме Лагранжа.

#table(rows: 2, columns: (1fr, 1fr, 1fr, 1fr, 1fr))[*$x$*][
  0][1][2][3][*$f(x)$*][1][2][9][28]

*Код*

```rust
pub fn lagrange_interpolation(x_nodes: &[f64],
                              f_nodes: &[f64],
                              x_targets: &[f64]) -> Vec<f64> {
    x_targets
        .iter()
        .map(|x| {
            f_nodes
                .into_iter()
                .zip(x_nodes)
                .enumerate()
                .map(|(k, (fk, xk))| {
                    let x_list_without_k = x_nodes[..k].iter().chain(&x_nodes[k + 1..]);

                    let numerator: f64 = x_list_without_k.clone().map(|xi| x - xi).product();
                    let denominator: f64 = x_list_without_k.map(|xi| xk - xi).product();

                    fk * numerator / denominator
                })
                .sum()
        })
        .collect()
}
```

*Результат*

```
Интерполяционный многолчен в форме Лагранжа l_3
+---+---+-------+---+-------+---+--------+----+
| x | 0 | 0.5   | 1 | 1.5   | 2 | 2.5    | 3  |
+=============================================+
| f | 1 | 1.125 | 2 | 4.375 | 9 | 16.625 | 28 |
+---+---+-------+---+-------+---+--------+----+
```



= Интерполяционный многочлен в форме Ньютона

*Условие*

По данным интерполяции из предыдущего задания построить интерполяционный многочлен
в форме Ньютона.

#table(rows: 2, columns: (1fr, 1fr, 1fr, 1fr, 1fr))[*$x$*][
  0][1][2][3][*$f(x)$*][1][2][9][28]

*Код*

```rust
pub fn newton_interpolation(x_nodes: &[f64], f_nodes: &[f64], x_targets: &[f64]) -> Vec<f64> {
    let diffs = separated_differences(x_nodes, f_nodes);
    x_targets
        .iter()
        .map(|x| {
            f_nodes[0]
                + (1..x_nodes.len())
                    .map(|i| diffs[i][0] * (0..=i - 1).map(|j| (x - x_nodes[j])).product::<f64>())
                    .sum::<f64>()
        })
        .collect()
}

fn separated_differences(x_nodes: &[f64], f_nodes: &[f64]) -> Vec<Vec<f64>> {
    let n = x_nodes.len() - 1;
    (1..=n).fold(vec![f_nodes.to_vec()], |mut acc, l| {
        acc.push(
            (0..=n - l)
                .map(|k| (acc[l - 1][k + 1] - acc[l - 1][k]) / (x_nodes[k + l] - x_nodes[k]))
                .collect(),
        );
        acc
    })
}
```

*Результат*

```
Интерполяционный многолчен в форме Ньютона N_3
+---+---+-------+---+-------+---+--------+----+
| x | 0 | 0.5   | 1 | 1.5   | 2 | 2.5    | 3  |
+=============================================+
| f | 1 | 1.125 | 2 | 4.375 | 9 | 16.625 | 28 |
+---+---+-------+---+-------+---+--------+----+
```


= Интерполяция кубическими сплайнами

*Условие*

Необходимо построить интерполяционный многочлен с помощью кубических сплайнов
(алгебраических многочленов третьей степени, где сплайн --- фрагмент, отрезок чего-либо).

#table(rows: 2, columns: (1fr, 1fr, 1fr, 1fr, 1fr))[*$x$*][
  0][1][2][3][*$f(x)$*][1][2][9][28]

*Код*

```rust
```

*Результат*

```
```


= Метод Гаусса решения СЛАУ

*Условие*

Решить следующую СЛАУ методом Гаусса
Метод Гаусса должен решать уравнения вида $A x = b$, где $A$ - матрица.
Для упрощения тестирования матрица $А$ примет вид:

$
  A = mat(18, 0.18, 0.18, 0.18, 0.18;
      0.19, 19, 0.19, 0.19, 0.19;
      0.20, 0.20, 20, 0.20, 0.20;
      0.21, 0.21, 0.21, 21, 0.21;
      0.22, 0.22, 0.22, 0.22, 22) quad
  b = mat(18;19;20;21;22).
$

*Код*

```rust
```

*Результат*

```
```


=	Метод прогонки решения СЛАУ (трехдиагональных)

*Условие*
В данном случае решается система линейных уравнений вида $A x = b$, где $A$ --- матрица вида:

$
    mat(
      -18, 0.18, 0, 0, 0;
      0.18, -19, 0.19, 0, 0;
      0, 0.19, -20, 0.20, 0;
      0, 0, 0.20, -21, 0.21;
      0, 0, 0, 0.21, -22) x = mat(18; 19; 20; 21; 22).
$

*Код*

```rust
```

*Результат*

```
```

= Метод простой итерации

*Условие*

При решении СЛАУ вида $A x = b$, где $A$ --- квадратная матрица, мы можем преобразовать ее к эквивалентному виду:

$
  mat(0, - a_12/a_11, ..., -a_(1 n) / a_11;
      -a_21/a_22, 0, ..., -a_(2 n)/a_22;
      dots.v, dots.v, dots.down, dots.v;
    -a_(n 1)/a_(n n), -a_(n 2)/a_(n n), ..., 0
    )
  x = mat(b_1 / a_11; b_2 / a_22; dots.v; b_n / a_(n n)).
$

Таким образом исходная система допускает представление в виде:

$
 alpha x + beta = x,
$

а критерий остановки вычислений:

$
  ||x^(k) - x^(k-1)|| < e.
$

*Код*

```rust
```

*Результат*

```
```
